# Генеральная совокупность - это множество, которое содержит данные обо всех объектах, соответствующих определенным характеристикам.
# Генеральная совокупность. Математическое ожидание — среднее значение случайной величины при стремлении количества выборок 
# или количества измерений к бесконечности. 

# Выборка - это случайным образом выбранная часть генеральной совокупности.
# Выборка. Оценка математического ожидания - это среднее арифметическое одномерной случайной величины конечного числа 
# испытаний обычно называют оценкой математического ожидания.

# Основная задача математического ожидания - показать, вокруг какого значения 
# группируется большая доля значений случайной величины. Математическое ожидание очень чувствительно к выбросам

# Среднее квадратичное отклонение показывает, насколько далеко наблюдения могут быть "разбросаны" относительно среднего значения.


# Генеральная совокупность. Смещенные стандартное отклонение и дисперсия.

import numpy as np

x = np.array([167, 181, 174, 178, 175, 164, 182, 178, 193, 166, 154, 170, 177])

np.std(x) # Смещенное стандартное отклонение (Standard deviation)
print(np.std(x))

np.var(x) # Смещенная дисперсия (Variance)
print(np.var(x))

print(np.sqrt(np.var(x))) # Корень из дисперсии - стандартное отклонение

# Выборка. Несмещенные стандартное отклонение и дисперсия

np.std(x, ddof=1) # Несмещенное стандартное отклонение, ddof - степени свободы = 1
print(np.std(x, ddof=1))

np.var(x, ddof=1) # Несмещенная дисперсия
print(np.var(x, ddof=1))

print(np.sqrt(np.var(x, ddof=1)))



# Медиана – значение, которое делит выборку на две равные части так, что значения, которые меньше медианы, 
# составляют 50% выборки
# Медиана для нечетного числа элементов n: N[(n+1)/2]
# Медиана для четного числа элементов n: (N[n/2] + N[n/2 + 1]) / 2


z = np.array([100, 80, 75, 77, 89, 33, 45, 25, 65, 17, 30, 24, 57, 55, 70, 75, 65, 84, 90, 150])

z.shape # Объем выборки
print(z.shape) # 20

z.sort() # Сортировка по возрастанию

(z[9] + z[10] / 2) # Медиана четного числа элементов. Нумерация идет с 0


# Мода - наиболее часто встречающееся в выборке значение.

# Первый квартиль - такое значение, что  25% наблюдений в выборке не превышают эту величину.
# Второй квартиль - синоним медианы.
# Третий квартиль - такое значение, что 75% наблюдений в выборке не превышают эту величину.
# Интерквартильное расстояние - отрезок,  равный разности 3-го и 1-го квартиля

z = np.array([1, 2, 4, 2, 1, 5, 7, 2, 3, 5, 7, 8, 9])

z.sort()

# Если nk/100 целое число, то k-я перцентиль - это среднее значение элементов
# под номерами nk/100 и nk/100+1
# Если nk/100 не целое число, то k-я перцентиль совпадает с измерением j+1, где 
# j - максимальное целое число, которое меньше, чем k/100

n = len(z)
k = 25 # Первый квартиль (т.е. 25-я перцентиль)

print(n*k/100) # 3,25
print(3 + 1) # j+1, 4-й элемент, т.е. с индексом 3
print(z[3]) # 2

k = 75 # Третий квартиль (т.е. 75-я перцентиль)
print(n*k/100) # 9,75
print(9 + 1) # j+1, 10-й элемент, т.е. с индексом 9
print(z[9]) # 7

print(z[9] - z[3]) # Интерквартильное расстояние = 5

# Размах R = X max  - X min. Очень чувствителен к выбросам



# Найти среднее арифметическое для выборки: 77, 79, 67, 95, 87, 91, 98, 100, 104, 105. 
# Найти медиану. Найти интерквартильное расстояние.

x = np.array([77, 79, 67, 95, 87, 91, 98, 100, 104, 105])

average = sum(x) / len(x)
print(average, np.mean(x)) # 90,3 среднее арифметическое

x.sort() # [67  77  79  87  91  95  98 100 104 105]
print(x, len(x)) # 10 элементов, четное число

n = len(x)
a = int(n / 2 - 1)
b = int(n / 2)

med = (x[a] + x[b]) / 2
print(med, np.median(x)) # 93, медиана

k1 = 25
k2 = 75

print(n*k1/100, n*k2/100) # 2.5, 7.5

j1 = int(n*k1/100)
j2 = int(n*k2/100)
print(j1, j2)

# k-я перцентиль совпадает с измерением j+1
print(x[j1], x[j2]) # 79 и 100
print(x[j2] - x[j1]) # интерквартильное расстояние



# Партия электрических лампочек на 25% изготовлена 1-м заводом, на 35% - 2-м заводом, 
# на 40% - третьим. Вероятности выпуска бракованных лампочек соответственно равны: 
# q1 = 0.03, q2 = 0.02, q3 = 0.01. Какова вероятность того, что наудачу взятая лампочка окажется бракованной?

# А - лампочка бракованная
# B1 - лампочка изготовлена 1 заводом P(B1) = 0,25
# B2 - лампочка изготовлена 2 заводом P(B2) = 0,35
# B3 - лампочка изготовлена 3 заводом P(B3) = 0,4

# P(A) = P(B1)*P(A|B1) + P(B2)*P(A|B2) + P(B3)*P(A|B3)

P = 0.25*0.03 + 0.35*0.02 + 0.4*0.01
print(P)



# в урне a красных и b  голубых шаров, одинаковых по размеру и весу. 
# Чему равна вероятность того, что наудачу извлеченный шар из этой урны окажется голубым? 
# Записать ответ в виде буквенного  выражения. 

# P = math.comb(b, 1) / math.comb(a+b, 1) = b / a+b




# Партия деталей изготовлена тремя рабочими, причем первый изготовил 35% всех деталей, второй – 40% всех деталей, 
# третий – всю остальную продукцию. Брак в их продукции составляет: у первого - 2%, у второго - 3%, у третьего – 4%. 
# Случайно выбранная для контроля деталь оказалась бракованной. Найти вероятность того, что она изготовлена третьим рабочим. 

# А - брак
# B1 - изготовил 1 рабочий P(B1) = 0,35
# B2 - изготовил 2 рабочий P(B2) = 0,4
# B3 - изготовил 3 рабочий P(B3) = 0,25

# P(A) = P(B1)*P(A|B1) + P(B2)*P(A|B2) + P(B3)*P(A|B3)
# P(B3|A) = P(A|B3) * P(B3) / P(A)

P = 0.04 * 0.25 / (0.35*0.02 + 0.4*0.03 + 0.25*0.04)
print(P)





# В ящике 15 шаров, из которых 5 голубы и 10 красных. Из ящика последовательно вынимают 2 шара; первый шар в ящик не возвращают. 
# Найти вероятность, что первый вытащенный шар  - красный , а второй – голубой. 

import math

P1 = math.comb(10, 1) / math.comb(15, 1)
P2 = math.comb(5, 1) / math.comb(14, 1)
P = P1 * P2
# P = (10/15) * (5/14)
print(P1, P2, P)



# Известно, что в принятой для сборки партии из 1000 деталей имеются 4 дефектных. 
# Найдите вероятность, что среди 50 случайно взятых деталей нет дефектных.

# Фоормула Бернулли

n = 50
k = 50
p = 0.996
q = 1 - p

P = math.comb(n, k) * pow(p, k) * pow(q, (n-k))

print(P)

